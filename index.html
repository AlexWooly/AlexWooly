<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AlexWoo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="王凌奕的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="AlexWoo">
<meta property="og:url" content="https://alexwooly.gitee.io/index.html">
<meta property="og:site_name" content="AlexWoo">
<meta property="og:description" content="王凌奕的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="AlexWoo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AlexWoo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AlexWoo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">王凌奕的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexwooly.gitee.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T15:15:31.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池（篇九）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程池-非原创"><a href="#线程池-非原创" class="headerlink" title="线程池(非原创)"></a>线程池(非原创)</h1><h2 id="线程池是什么？"><a href="#线程池是什么？" class="headerlink" title="线程池是什么？"></a>线程池是什么？</h2><blockquote>
<p>java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池</p>
</blockquote>
<p>线程的资源很宝贵，不可能无限的创建，必须要有管理线程的工具，线程池就是一种管理线程的工具，java开发中经常有池化的思想，如 数据库连接池、Redis连接池等。预先创建好一些线程，任务提交时直接执行，既可以节约创建线程的时间，又可以控制线程的数量。</p>
<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ol>
<li>降低资源消耗，通过池化思想，减少创建线程和销毁线程的消耗，重复利用的效果，节省资源</li>
<li>提高响应速度，任务到达时，无需创建线程即可运行，相对于从线程池拿线程，重新创建线程执行要慢很多</li>
<li>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程本身也是一个对象，创建需要经过类加载，回收也要GC回收。</li>
</ol>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   												BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">   												ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">   												RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure>

<p><strong>核心参数</strong></p>
<p>corePoolSize：核心线程的数量<br>maximumPoolSize：线程池中最大的线程数量<br>keepAliveTime：线程池中非核心线程空闲的存活时间<br>TimeUnit：线程空闲存活时间的时间单位<br>workQueue：存放任务的阻塞队列<br>threadFactory：用于创建核心线程的线程工厂，可以给创建的线程自定义名字，方便查日志<br>handler：线程池的饱和策略（拒绝策略），有四种类型。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><img src="/2021/05/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/xcc1.png" width="70%" height="60%">

<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ul>
<li>AbortPolicy：抛出一个异常，默认的拒绝策略</li>
<li>DiscardPolicy：直接丢弃任务</li>
<li>DiscardOldestPolicy：丢弃队列里最老的任务，将当前这个任务继续提交给线程池。</li>
<li>CallerRunsPolicy：交给线程池调用所在的线程进行处理。</li>
</ul>
<h3 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h3><p><strong>ArrayBlockingQueue</strong></p>
<p>有界队列，是一个用数组实现的有界阻塞队列，按FIFO排序。</p>
<p><strong>LinkedBlockingQueue</strong></p>
<p>基于链表实现的阻塞队列，按FIFO排序任务，容量可以设置，不设置的话将是一个无边界的阻塞队列（最大长度是Integet.Max_VLAUE），吞吐量通常要高于ArrayBlockingQueue；newFixedThreadPool线程池使用了这个队列。</p>
<p><strong>DelayQueue</strong></p>
<p>DelayQueue是一个任务定时周期延迟执行的队列。根据指定的执行从小到大排序，否则根据插入到队列的先后顺序。newScheduledThreadPool线程池使用了这个队列。</p>
<p><strong>PriorityBlockingQueue</strong></p>
<p>优先级队列是具有优先级的无界阻塞队列。</p>
<p><strong>SynchronousQueue</strong></p>
<p>同步队列，一个不存储元素的阻塞队列，每个插入操作都必须等待另一个线程调用移除操作，否则插入操作将一直处于阻塞状态。吞吐量通常要高于LinkedBlockingQueue，newCachedThreadPool使用了这个队列。</p>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><ul>
<li>newFixedThreadPool（固定数目线程的线程池，内部使用LinkedBlockingQueue）</li>
<li>newCachedThreadPool（可缓存线程的线程池，内部使用SynchronousBlockingQueue）</li>
<li>newSingleThreadPool（单线程的线程池，内部使用LinkedBlockingQueue）</li>
<li>newScheduledThreadPool（定时及周期性执行的线程池，内部使用DelayQueue）</li>
</ul>
<p><strong>newFixedThreadPool</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程池特点</p>
<ul>
<li>核心线程数量=最大线程数量</li>
<li>没有所谓的非空闲时间，即keepAliveTime=0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue 提交任务的执行流程参照ThreadPoolExecutor及newFixedThreadPool自行得出。此处有</li>
<li>个问题：使用无界队列的线程池会导致内存飙升吗？答案是会的。因为如果提交的任务很多，超过了newFixedThreadPool设置的核</li>
<li>心线程数，会一直往无界队列里塞任务，任务累积越来越多，导致机器内存飙升，直到OOM。</li>
<li>使用场景：newFixedThreadPool适用于处理CPU密集型的任务，确保CPU在长期工作线程使用的情况下，尽可能少的分配线程。</li>
</ul>
<p><strong>newCachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                   <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>线程池特点：</p>
<ul>
<li>核心线程数为0，最大线程树为Integer.Max_VALUE</li>
<li>非核心线程空闲的存活时间为60s</li>
<li>阻塞队列是SynchronousQueue</li>
<li>执行流程参照ThreadPoolExecutor和池特点自行得出。这个池也有一个问题：当提交任务的数量大于处理任务的数量时，每次提交一</li>
<li>个任务必然会创建一个非核心线程，极端情况下会创建过多的线程（最大Integer.Max_VALUE），耗尽CPU和内存资源。当然如果没</li>
<li>有任务了，这些空闲的非核心线程在存活60s后被回收。使用场景：用于并发量大执行大量短期的小任务。</li>
</ul>
<p><strong>newSingleThreadExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">          (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程池特点：</p>
<ul>
<li>核心线程数=最大线程数=1，也就是这个池子里从始最终只有一个活着的线程。</li>
<li>keepAliveTime=0，这个参数无效。</li>
<li>阻塞队列是无界的LinkedBlockingQueue</li>
<li>提交任务的执行流程可自行得出。其实这个池子里干活的只有一个人，不管你往里塞多少任务，都是它按部就班的从队列里获取任务</li>
<li>执行，适用于串行执行任务的情景，一个任务接一个任务的执行。</li>
</ul>
<p><strong>newScheduledThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池特点：</p>
<ul>
<li>核心线程数自定义，最大线程数为Integer.MAX_VALUE</li>
<li>keepAliveTime=0</li>
<li>阻塞队列为DelayedWorkQueue 这里scheduleAtFixedRate和scheduleWithFixedDelay两个方法的区别如下：</li>
<li>scheduleAtFixedRate：按某种速率周期性的执行，不管上一个任务有没有执行结束。也就是说是从上一个任务开始执行算起的+一个</li>
<li>周期作为下一个任务的开始执行时间。</li>
<li>scheduleWithFixedDelay：在某个延迟后执行，是要等上一个任务执行结束算起的。也就是说是从上一个任务执行结束时间+一个周</li>
<li>期作为下一个任务的开始执行时间。</li>
<li>使用场景：周期性的执行任务的场景，做一些简单的定时调度。</li>
</ul>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p><strong>RUNNING</strong></p>
<p>该状态的线程池会接收新任务，并处理阻塞队列中的任务<br>调用shutdown()方法可以切换到SHUTDOWN状态<br>调用shutdownNow()方法可以切换到STOP状态</p>
<p><strong>SHUTDOWN</strong></p>
<p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务<br>队列为空，并且线程池中执行的任务也为空，进入TIDYING状态</p>
<p><strong>STOP</strong></p>
<p>该状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在执行中的任务<br>线程池中执行的任务一旦变为空，进入TIDYING状态</p>
<p><strong>TIDYING</strong></p>
<p>该状态表明所有的任务已经运行终止，记录的任务数量为0<br>terminated()执行完毕，进入TERMINATED状态</p>
<p><strong>TERMINATED</strong></p>
<p>该状态表明线程池彻底终止或死亡</p>
<h3 id="常用并发工具类"><a href="#常用并发工具类" class="headerlink" title="常用并发工具类"></a>常用并发工具类</h3><p><strong>CountDownLatch和CyclicBarrier</strong></p>
<p>CountDownLatch具有计数器的功能，意思是主线程遇到CountDownLatch阻塞在那，要等待CountDownLatch里的所有线程都执行完毕，主线程才能继续执行。需要注意的是CountDownLatch创建的线程数和每个线程里countDown的总次数需要和初始化CountDownLatch传入的线程数相等，不然的话主线程将一直处于等待状态。</p>
<p>CyclicBarrier就是循环栅栏，意思是多个线程相互阻塞，只有多个线程都达到了栅栏时候，才能同时执行后续的逻辑。区别就是CountDownLatch是一个线程（或多个）等待另外的N个线程完成某个事情后才能执行。CyclicBarrier是N个线程相互等待，任何一个线程达到栅栏前，所有线程都阻塞在那。</p>
<p>下面给两个Demo<br>一个老师（主线程）等10个学生（其他线程）都来教室了才开始上课。是CountdownLatch模型。</p>
<p>public class CountDownLatchDemo {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer STUDENT_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(STUDENT_COUNT);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    Thread teacher = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Teacher());</span><br><span class="line">    teacher.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;STUDENT_COUNT; i++) &#123;</span><br><span class="line">        Thread student = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Student());</span><br><span class="line">        student.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;来了，等所有同学都到了才上课...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有同学都到齐了，开始上课...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同学&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;进入了教室...&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个任务需要10个工人（10个线程）都到岗之后才能开始进行，否则只能等待，是CyclicBarrier模型。</p>
<p>public class CyclicBarrierDemo {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORKER_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(WORKER_COUNT, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(WORKER_COUNT+<span class="string">&quot;个工人已就位，可以开始干活了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;WORKER_COUNT; i++) &#123;</span><br><span class="line">        Thread worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker());</span><br><span class="line">        worker.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工人&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;就位...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore</strong></p>
<p>Semaphore信号量，就是用来控制访问有限资源的线程数量，线程要访问资源首先要获得许可证，一个许可证对应一个资源，如果资源不足了，线程就要等待，如果其他线程释放了一个资源（许可证），那么信号量就通知等待的一个线程，分配给它一个许可证。内部实现这里不再赘述，下面是4个人看电影，但是电影院只有2个位置，也就是一次只能2个人在里面看（这里限制不能站着看），有人离开位置，后面的人才可以进来看电影。</p>
<p>public class SemaphoreDemo {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer SETS_NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer PERSON_NUMBER = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    WatchMovie watchMovie = <span class="keyword">new</span> WatchMovie(SETS_NUMBER);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;PERSON_NUMBER; i++) &#123;</span><br><span class="line">        Thread person = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(watchMovie));</span><br><span class="line">        person.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchMovie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    WatchMovie(<span class="keyword">int</span> setCount) &#123;</span><br><span class="line">        semaphore = <span class="keyword">new</span> Semaphore(setCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取信号量</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="keyword">long</span> time = (<span class="keyword">long</span>) (Math.random()*<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;看了&quot;</span>+time+<span class="string">&quot;秒的电影&quot;</span>);</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;让出座位，离开了电影院&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放信号量</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WatchMovie watchMovie;</span><br><span class="line"></span><br><span class="line">    Person(WatchMovie watchMovie) &#123;</span><br><span class="line">        <span class="keyword">this</span>.watchMovie = watchMovie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        watchMovie.watchMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exchanger</strong></p>
<p>Exchanger理解其意思就行，就是线程间的数据交换。是怎么交换呢？实际上是共用一个Exchange的多个线程，在全部都到达栅栏的时候才可以进行数据的交换，否则的话先到达的线程只能等待其他的线程达到栅栏。那怎么才算到达栅栏呢，就是线程内部调用exchanger.exchange方法。然后这个方法的返回值就是其他线程交换的数据，参数就是当前线程想要交还给其他线程的数据。</p>
<h3 id="三大并发容器"><a href="#三大并发容器" class="headerlink" title="三大并发容器"></a><strong>三大并发容器</strong></h3><p>1.<strong>CopyOnWrite</strong></p>
<p>2.<strong>ConcurrentHashMap</strong></p>
<p>实现机制就是读写分离，简单的说就是任何时候都可以读，写需要加锁，写时复制。什么是写复制呢？就是对容器的修改加锁后，通过copy一个新的容器来进行修改，修改完毕后将容器替换为新的容器。</p>
<p><strong>Node数组+链表+红黑树</strong>(难到没有朋友，等有朝一日我学会了再来补充)</p>
<p>3.<strong>ConcurrentSkipListMap</strong></p>
<p>ConcurrentSkipListMap内部使用跳表的数据结构来实现，他的结构很简单。跳表就是一个多层的链表，底层是一个普通的链表，然后逐层减少，通常通过一个简单的算法实现每一层元素是下一层的元素的二分之一，这样当搜索元素时从最顶层开始搜索，可以说是另一种形式的二分查找。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="ckoo7ikei0000r69ific63o11" data-title="线程池（篇九）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式架构理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2021-05-11T09:16:39.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/">分布式架构理论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分布式架构理论"><a href="#分布式架构理论" class="headerlink" title="分布式架构理论"></a>分布式架构理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP定理: 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得</p>
<ul>
<li><p>一致性（C）：所有节点都可以访问到最新的数据</p>
</li>
<li><p>可用性（A）：每个请求都是可以得到响应的，不管请求是成功还是失败</p>
</li>
<li><p>分区容错性（P）：除了全部整体网络故障，其他故障都不能导致整个系统不可用</p>
</li>
<li><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡</p>
<img src="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/CAP1.png" width="40%" height="40%"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CA： 如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的</span><br><span class="line"></span><br><span class="line">CP: 如果不要求A（可用），每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统</span><br><span class="line"></span><br><span class="line">AP：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</span><br></pre></td></tr></table></figure>

<h3 id="注册中心的选择"><a href="#注册中心的选择" class="headerlink" title="注册中心的选择"></a>注册中心的选择</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>Nacos</strong></th>
<th align="left"><strong>Eureka</strong></th>
<th align="left"><strong>Consul</strong></th>
<th align="left"><strong>Zookeeper</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">一致性协议</td>
<td align="left">CP+AP</td>
<td align="left">AP</td>
<td align="left">CP</td>
<td align="left">CP</td>
</tr>
<tr>
<td align="left">健康检查</td>
<td align="left">TCP/HTTP/MYSQL/Client Beat</td>
<td align="left">心跳</td>
<td align="left">TCP/HTTP/gRPC/Cmd</td>
<td align="left">Keep Alive</td>
</tr>
<tr>
<td align="left">雪崩保护</td>
<td align="left">有</td>
<td align="left">有</td>
<td align="left">无</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">访问协议</td>
<td align="left">HTTP/DNS</td>
<td align="left">HTTP</td>
<td align="left">HTTP/DNS</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">SpringCloud集成</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
</tbody></table>
<ul>
<li>分布式系统中P,肯定要满足，所以只能在CA中二选一</li>
<li>没有最好的选择，最好的选择是根据业务场景来进行架构设计</li>
<li>如果要求一致性，则选择zookeeper/Nacos，如金融行业 CP</li>
<li>如果要求可用性，则Eureka/Nacos，如电商系统 AP</li>
<li>CP ： 适合支付、交易类，要求数据强一致性，宁可业务不可用，也不能出现脏数据</li>
<li>AP: 互联网业务，比如信息流架构，不要求数据强一致，更想要服务可用</li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由来自 ebay 的架构师提出:CAP 中的一致性和可用性进行一个权衡的结果，核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Basically Available(基本可用)</p>
<ul>
<li>假设系统，出现了不可预知的故障，但还是能用, 可能会有性能或者功能上的影响</li>
</ul>
</li>
<li><p>Soft state（软状态）</p>
<ul>
<li>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时</li>
</ul>
</li>
<li><p>Eventually consistent（最终一致性）</p>
<ul>
<li>系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/" data-id="ckojts1g50001os9iekt4eqlj" data-title="分布式架构理论" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基本数据结构及其操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T11:07:38.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C/">Java基本数据结构及其操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-数组"><a href="#一-数组" class="headerlink" title="一.数组"></a>一.数组</h2><p>最常见数据结构</p>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> as = a.length;</span><br><span class="line">        <span class="keyword">int</span> a1 = a[<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        Integer[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(c, (o1, o2) -&gt; o1 - o2);         <span class="comment">//升序</span></span><br><span class="line">        Arrays.sort(c, (o1,o2) -&gt; o2.compareTo(o1)); <span class="comment">//降序</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(arr.toString());</span><br><span class="line">        arr.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        arr.add(<span class="number">2</span>);</span><br><span class="line">        arr.remove(<span class="number">0</span>);  <span class="comment">//索引或元素本身</span></span><br><span class="line">        arr.set(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> arrs = arr.size();</span><br><span class="line">        <span class="keyword">boolean</span> is2 = arr.contains(<span class="number">2</span>);</span><br><span class="line">        Collections.sort(arr);</span><br><span class="line">        Collections.sort(arr,Collections.reverseOrder());</span><br><span class="line">        arr.sort(Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h2><p>离散存储线性结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linkedlist</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> element = list.get(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(<span class="number">10</span>);</span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">11</span>);</span><br><span class="line">        list.remove(<span class="number">2</span>);  <span class="comment">//索引</span></span><br><span class="line">        <span class="keyword">int</span> length = list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>leetcode常用自定义链表对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>leetcode的第19题记录ListNode的使用</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode ans=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//定义一个头节点</span></span><br><span class="line">        ans.next=head;<span class="comment">//头节点指向这个链表</span></span><br><span class="line">        ListNode listnode = ans;<span class="comment">//每次调用这个链表只需要定义一个节点等于这个头节点</span></span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(listnode.next!=<span class="keyword">null</span>)&#123;<span class="comment">//统计链表长度</span></span><br><span class="line">            length++;</span><br><span class="line">            listnode=listnode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp =ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next=temp.next.next;<span class="comment">//在倒数第n个位置前使链表的当前节点指向n的下一个位置</span></span><br><span class="line">        <span class="keyword">return</span> ans.next;<span class="comment">//这样做最后返回这个头节点的next就是返回了这个新的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-队列"><a href="#三-队列" class="headerlink" title="三.队列"></a>三.队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tqueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line">        <span class="keyword">int</span> q1 = queue.peek();  <span class="comment">//get</span></span><br><span class="line">        <span class="keyword">int</span> q2 = queue.poll();  <span class="comment">//remove and get</span></span><br><span class="line">        <span class="keyword">boolean</span> it = queue.isEmpty();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tem = queue.poll();</span><br><span class="line">            System.out.println(tem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-栈"><a href="#四-栈" class="headerlink" title="四.栈"></a>四.栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSatck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack.toString());</span><br><span class="line">        stack.peek();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.size();</span><br><span class="line">        stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-哈希表"><a href="#五-哈希表" class="headerlink" title="五.哈希表"></a>五.哈希表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThashTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.size();</span><br><span class="line">        map.isEmpty();</span><br><span class="line">        map.containsKey(<span class="number">1</span>);</span><br><span class="line">        map.containsValue(<span class="string">&quot;wly&quot;</span>);</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;wly&quot;</span>);</span><br><span class="line">        map.get(<span class="number">1</span>);</span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-堆"><a href="#六-堆" class="headerlink" title="六.堆"></a>六.堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Theap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1,Integer i2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//PriorityQueue&lt;Integer&gt; maxheap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span></span><br><span class="line">        minHeap.peek();</span><br><span class="line">        maxHeap.poll();</span><br><span class="line">        maxHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-集合"><a href="#七-集合" class="headerlink" title="七.集合"></a>七.集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.contains(<span class="number">2</span>);</span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C/" data-id="ckojts1g20000os9i3j3h09ga" data-title="Java基本数据结构及其操作" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常用sql（MySQL）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/06/%E5%B8%B8%E7%94%A8sql%EF%BC%88MySQL%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-05-06T13:54:06.000Z" itemprop="datePublished">2021-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/06/%E5%B8%B8%E7%94%A8sql%EF%BC%88MySQL%EF%BC%89/">常用sql（MySQL）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中常用sql语句"><a href="#MySQL中常用sql语句" class="headerlink" title="MySQL中常用sql语句"></a>MySQL中常用sql语句</h1><p>关于sql语句的学习W3school 刷题LeetCode</p>
<p>部分只记录下我掌握不熟练的语句和用法</p>
<p>1.distinct 列出不同的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student <span class="keyword">FROM</span> School </span><br></pre></td></tr></table></figure>

<p>2.update</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名称 <span class="keyword">SET</span> 列名称 <span class="operator">=</span> 新值 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 某值</span><br><span class="line">UPDATE Person <span class="keyword">SET</span> FirstName <span class="operator">=</span> <span class="string">&#x27;Fred&#x27;</span> <span class="keyword">WHERE</span> LastName <span class="operator">=</span> <span class="string">&#x27;Wilson&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>3.delete</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 值</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> LastName <span class="operator">=</span> <span class="string">&#x27;Wilson&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>4.order by 语句用于对结果集进行排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company, OrderNumber</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>    <span class="operator">/</span><span class="operator">/</span>逆序</span><br></pre></td></tr></table></figure>

<p>5.通配符</p>
<table>
<thead>
<tr>
<th>%</th>
<th align="center">替代一个或多个字符</th>
</tr>
</thead>
<tbody><tr>
<td>_</td>
<td align="center">仅替代一个字符</td>
</tr>
<tr>
<td>[charlist]</td>
<td align="center">字符列中的任何单一字符</td>
</tr>
<tr>
<td>[^charlist]或者[!charlist]</td>
<td align="center">不在字符列中的任何单一字符</td>
</tr>
</tbody></table>
<p>6.as 指定别名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LastName <span class="keyword">AS</span> Family, FirstName <span class="keyword">AS</span> Name</span><br><span class="line"><span class="keyword">FROM</span> Persons <span class="keyword">AS</span> p</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>JOIN</p>
<p>​        left join :左连接，返回左表中所有的记录以及右表中连接字段相等的记录。</p>
<p>　　right join :右连接，返回右表中所有的记录以及左表中连接字段相等的记录。</p>
<p>　　inner join: 内连接，又叫等值连接，只返回两个表中连接字段相等的行。</p>
<p>　　full join:外连接，返回两个表中的行：left join + right join。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName</span><br></pre></td></tr></table></figure></li>
<li><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br></pre></td></tr></table></figure>

<p>默认地，UNION 操作符选取不同的值。如果允许重复的值，使用 UNION ALL</p>
</li>
<li><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] </span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br></pre></td></tr></table></figure></li>
<li><p>Date</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_now.asp">NOW()</a></td>
<td align="left">返回当前的日期和时间</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_curdate.asp">CURDATE()</a></td>
<td align="left">返回当前的日期</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_curtime.asp">CURTIME()</a></td>
<td align="left">返回当前的时间</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date.asp">DATE()</a></td>
<td align="left">提取日期或日期/时间表达式的日期部分</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_extract.asp">EXTRACT()</a></td>
<td align="left">返回日期/时间按的单独部分</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date_add.asp">DATE_ADD()</a></td>
<td align="left">给日期添加指定的时间间隔</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date_sub.asp">DATE_SUB()</a></td>
<td align="left">从日期减去指定的时间间隔</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_datediff_mysql.asp">DATEDIFF()</a></td>
<td align="left">返回两个日期之间的天数</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date_format.asp">DATE_FORMAT()</a></td>
<td align="left">用不同的格式显示日期/时间</td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL 使用下列数据类型在数据库中存储日期或日期<span class="operator">/</span>时间值：</span><br><span class="line"></span><br><span class="line"><span class="type">DATE</span> <span class="operator">-</span> 格式 YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD</span><br><span class="line">DATETIME <span class="operator">-</span> 格式: YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD HH:MM:SS</span><br><span class="line"><span class="type">TIMESTAMP</span> <span class="operator">-</span> 格式: YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD HH:MM:SS</span><br><span class="line"><span class="keyword">YEAR</span> <span class="operator">-</span> 格式 YYYY 或 YY</span><br></pre></td></tr></table></figure>

<p>11.IS NULL 和 IS NOT NULL 操作符</p>
<p>函数</p>
<p>1.count</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(Customer) <span class="keyword">AS</span> CustomerNilsen <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> Customer<span class="operator">=</span><span class="string">&#x27;Carter&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2.FIRST() 函数返回指定的字段中第一个记录的值。Last( )</p>
<p>配合 ORDER BY 语句对记录进行排序。 MAX（）MIN( )</p>
<p>3.SUM( )</p>
<p>4.GROUP BY 语句</p>
<p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组</p>
<p>5.HAVING 子句</p>
<p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customer,<span class="built_in">SUM</span>(OrderPrice) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customer</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(OrderPrice)<span class="operator">&lt;</span><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>6.UCASE( ),LCASE( )大小写转换</p>
<ol start="7">
<li>LEN( ) 函数返回文本字段中值的长度。</li>
<li>ROUND 函数用于把数值字段舍入为指定的小数位数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(column_name,decimals) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>FORMAT 函数用于对字段的显示进行格式化</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FORMAT(column_name,format) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/06/%E5%B8%B8%E7%94%A8sql%EF%BC%88MySQL%EF%BC%89/" data-id="ckod38s9x0000sc9ih6u0c3tu" data-title="常用sql（MySQL）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/05/Redis3/" class="article-date">
  <time class="dt-published" datetime="2021-05-05T15:18:15.000Z" itemprop="datePublished">2021-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/05/Redis3/">Redis 事务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis-第三篇-Redis-事务"><a href="#Redis-第三篇-Redis-事务" class="headerlink" title="Redis 第三篇 Redis 事务"></a>Redis 第三篇 Redis 事务</h1><p>回到很多人抢购库存剩余为1的场景，抢购的时候是一个并发操作，系统发来多个并发请求。这批请求有的执行略慢，查询到库存为 0 于是购买失败；但有的请求执行较快，查询到数据库商品余量都是 1 个，然后都通过这一个余量判断，然后导致超发的情况。前面我们通过锁来解决。</p>
<blockquote>
<p>线程执行先后顺序和快慢，都是由操作系统、CPU 自动决定的，开发者无法预测</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>事务(Transaction) ，是指将一个业务逻辑作为一个整体一起执行。事务其实就是打包一组操作（或者命令）作为一个整体，在事务处理时将顺序执行这些操作，并返回结果，如果其中任何一个环节出错，所有的操作将被回滚。</p>
<p>redis 的事务指的是提供一种将多个命令打包，一次性按顺序地执行</p>
<p>redis 的事务可以保证只有在执行完事务中的所有命令后，才会继续处理此客户端的其他命令。也就是说只有一个用户可以操作事务当中的数据</p>
<h2 id="Redis-事务从开始到结束的三个过程"><a href="#Redis-事务从开始到结束的三个过程" class="headerlink" title="Redis 事务从开始到结束的三个过程"></a>Redis 事务从开始到结束的三个过程</h2><p><strong>开启事务 -&gt; 命令入列 -&gt;执行事务/放弃事务</strong></p>
<h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>四大指令：MULTI、EXEC、DISCARD、WATCH</p>
<p><strong>MULTI</strong>：开启一个事物</p>
<p><strong>EXEC</strong>：执行一个事物</p>
<p><strong>DISCARD</strong>：取消一个事物</p>
<p><strong>WATCH</strong>：用于客户端并发情况下，为事务提供一个锁（CAS，Check And Set）可以用 watch 命令来监控一个或多个变量如果在执行事务之前，某个监控项被修改了，那么整个事务就会终止执行（必须写在事务的前面，不能写在事务当中）</p>
<h3 id="对Redis-数据初始化的说明"><a href="#对Redis-数据初始化的说明" class="headerlink" title="对Redis 数据初始化的说明"></a>对Redis 数据初始化的说明</h3><p>既然 Redis 是缓存，就要考虑到什么时机把初始数据存入到数据库。下演示代码只是一种最简单的情况，抢购前从数据库里查库存，然后放入 Redis。实际上也可以在项目启动时初始化，在标记为 @PostConstruct 的方法中把输入存入 Redis。</p>
<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>一般为固定写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>图示理解</p>
<img src="/2021/05/05/Redis3/Redis3-1.png" width="60%" height="60%">

<h3 id="模拟抢购实例代码（Redis事务版）"><a href="#模拟抢购实例代码（Redis事务版）" class="headerlink" title="模拟抢购实例代码（Redis事务版）"></a>模拟抢购实例代码（Redis事务版）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title">snappedUp</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化返回数据</span></span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.data(<span class="keyword">true</span>);</span><br><span class="line">        result.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//实现购买代码</span></span><br><span class="line">        <span class="comment">//先去redis查询一下</span></span><br><span class="line">        Object value = redisTemplate.opsForValue().get(id);</span><br><span class="line">        <span class="keyword">int</span> stock = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果redis没有则去数据库查询</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//去数据库查询该商品的信息</span></span><br><span class="line">            ProductDO product = productDAO.selectById(id);</span><br><span class="line">            <span class="comment">//将信息缓存到redis里边</span></span><br><span class="line">            stock = product.getStock();</span><br><span class="line">            redisTemplate.opsForValue().set(product.getId(), stock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stock = (<span class="keyword">int</span>)value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                Integer stock = (Integer)operations.opsForValue().get(id);</span><br><span class="line">                <span class="comment">//判断该商品的库存是否大于1</span></span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(stock) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//监听商品的名字，redis里边的key  注意！！！！监听的不是stock而是商品id</span></span><br><span class="line">                    operations.watch(id);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//开启事务</span></span><br><span class="line">                    operations.multi();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将该商品的库存自减1</span></span><br><span class="line">                    operations.opsForValue().set(id, stock - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//修改mysql数据库库存数量</span></span><br><span class="line">                    ProductDO productDO = <span class="keyword">new</span> ProductDO();</span><br><span class="line">                    productDO.setId(id);</span><br><span class="line">                    productDO.setStock(stock - <span class="number">1</span>);</span><br><span class="line">                    productDAO.updateStock(productDO);</span><br><span class="line">                    <span class="comment">// 执行事务</span></span><br><span class="line">                    List exec = operations.exec();</span><br><span class="line">                    <span class="keyword">if</span> (exec.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span>可以有其它业务逻辑，例如插入订单等，视具体需求而定</span></span><br><span class="line">                        result.setMessage(<span class="string">&quot;抢购成功&quot;</span>);</span><br><span class="line">                        result.setData(<span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setMessage(<span class="string">&quot;抢购失败&quot;</span>);</span><br><span class="line">                        result.setData(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> exec;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setMessage(<span class="string">&quot;商品库存不足&quot;</span>);</span><br><span class="line">                    result.setData(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/05/Redis3/" data-id="ckocjcpjg0000r29i4p4y5eki" data-title="Redis 事务" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/Redis2/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T15:18:15.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/Redis2/">Redission</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis-第二篇-Redission"><a href="#Redis-第二篇-Redission" class="headerlink" title="Redis 第二篇 Redission"></a>Redis 第二篇 Redission</h1><p>上篇在写客户端的时候提到了我用的比较多的Redission，这节就顺着整理一下。</p>
<p>spring-boot-data-redis 默认使用 Lettuce 客户端操作数据。但Reddissin 很强大，它提供的功能远远超出了一个 Redis 客户端的范畴，使用它来替换默认的 Lettuce。在可以使用基本 Redis 功能的同时，也能使用它提供的一些高级服务：</p>
<ul>
<li>远程调用 </li>
<li>分布式锁 </li>
<li>分布式对象、容器</li>
</ul>
<p>简单讲一下分布式：分布式结构就是将一个完整的系统,按照业务功能,拆分成一个个独立的子系统,在分布式结构中，每个子系统就被称为“服务”。（演变过程：单机结构 -&gt; 集群结构 -&gt; 分布式结构）</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;redis启动主机ip</span><br><span class="line">spring.redis.host&#x3D;</span><br><span class="line">&#x2F;&#x2F;redis端口号</span><br><span class="line">spring.redis.port&#x3D;</span><br><span class="line">&#x2F;&#x2F;redis登录密码</span><br><span class="line">spring.redis.password&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="两个常用应用"><a href="#两个常用应用" class="headerlink" title="两个常用应用"></a>两个常用应用</h2><h3 id="一-分布式ID"><a href="#一-分布式ID" class="headerlink" title="一.分布式ID"></a>一.分布式ID</h3><p>ID 是数据的唯一标识，传统的做法是利用 UUID 和数据库的自增 ID。</p>
<p>但由于 UUID 是无序的，不能附带一些其他信息。比如需要生成员工号，这个一般是用数据库递增， UUID 是无法完成这个需求的。</p>
<p>再来说自增 ID，随着业务的发展，数据量会越来越大，需要对数据进行分表，甚至分库。分表后每个表的数据会按自己的节奏来自增，这样会造成 ID 冲突，这时就需要一个单独的机制来负责生成唯一 ID。</p>
<p>举例：淘宝的订单号</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RAtomicLong;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIdController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getautoid&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAutoId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化格式为年月日</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        String now = LocalDate.now().format(dateTimeFormatter);</span><br><span class="line">        <span class="comment">//通过redis的自增获取序号</span></span><br><span class="line">        RAtomicLong atomicLong = redissonClient.getAtomicLong(now);</span><br><span class="line">        atomicLong.expire(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        <span class="comment">//拼装订单号</span></span><br><span class="line">        <span class="keyword">return</span> now + <span class="string">&quot;&quot;</span> + atomicLong.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">202105041</span><br></pre></td></tr></table></figure>

<p>嫌不够长，还可以这样<strong>String.format(“%08d”, xxx);</strong>%04d 表示输出时指定格式为使用 0 在左侧补齐至 8 位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> now + <span class="string">&quot;&quot;</span> + String.format(<span class="string">&quot;%08d&quot;</span>,atomicLong.incrementAndGet());</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">202105040000002</span><br></pre></td></tr></table></figure>

<h3 id="二-分布式锁"><a href="#二-分布式锁" class="headerlink" title="二.分布式锁"></a>二.分布式锁</h3><p>锁，在 Java 中 synchronized 关键字很常见，这些都是<strong>本地锁</strong>，只能解决一台服务器并发问题。</p>
<p>但是随着业务量不断增大，单机结构不满足那么大的访问量，需要变成集群或者分布式结构，因此无法保证某个数据的改变是同一台服务器操作的。我们需要的是一个能锁所有服务器的锁，这时就需要<strong>分布式锁</strong>。</p>
<h4 id="实现Redis分布-三步"><a href="#实现Redis分布-三步" class="headerlink" title="实现Redis分布  三步"></a><strong>实现Redis分布  三步</strong></h4><h5 id="取得锁"><a href="#取得锁" class="headerlink" title="取得锁"></a>取得锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUSTOM_NAME 自定义锁名称字符串，一般是跟业务相关的名称</span></span><br><span class="line"> <span class="comment">//Rlock 继承于 java.util.concurrent.locks.Lock;(又是Lock类！！)</span></span><br><span class="line"> RLock rLock = redissonClient.getLock(<span class="string">&quot;CUSTOM_NAME&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上锁过程</span></span><br><span class="line"><span class="comment"> * 两种常用上锁方式tryLock()或者lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> rLock.tryLock();</span><br></pre></td></tr></table></figure>

<h5 id="解锁-有上锁就必须解锁，否则会导致死锁，系统也就卡死了。"><a href="#解锁-有上锁就必须解锁，否则会导致死锁，系统也就卡死了。" class="headerlink" title="解锁(有上锁就必须解锁，否则会导致死锁，系统也就卡死了。)"></a>解锁(有上锁就必须解锁，否则会导致死锁，系统也就卡死了。)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解锁</span></span><br><span class="line"> rLock.unlock();</span><br></pre></td></tr></table></figure>

<p>代码实操，模拟商品购买</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ProductController.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        products.add(<span class="keyword">new</span> Product(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        products.add(<span class="keyword">new</span> Product(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/purchase&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">purchase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取分布式锁</span></span><br><span class="line">        RLock transferLock = redissonClient.getLock(<span class="string">&quot;PURCHASE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        transferLock.lock();</span><br><span class="line">        <span class="comment">//业务逻辑卸载try...catch中 ，finally最后一定要释放锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//尝试获取锁</span></span><br><span class="line">            Product product = findById(<span class="string">&quot;1&quot;</span>); <span class="comment">//为了方便测试，直接写死，实际商品代码应有用户post</span></span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;商品已经卖完啦！！！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            product.setStock(product.getStock() - <span class="number">1</span>);</span><br><span class="line">            updateProduct(product);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品购买成功！！！&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;&quot;</span>,e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否出现异常，一定解锁</span></span><br><span class="line">            transferLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品购买失败&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询商品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 唯一id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Product</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Product <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            <span class="keyword">if</span> (product.getId().equals(id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Product <span class="title">updateProduct</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; products.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (products.get(i).getId().equals(product.getId())) &#123;</span><br><span class="line">                products.set(i, product);</span><br><span class="line">                <span class="keyword">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Product类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda.app.model;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/2, 周二</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品唯一Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long stock = <span class="number">2L</span>;  <span class="comment">//方便测试，请求到第三次时应该为购买失败</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStock</span><span class="params">(<span class="keyword">final</span> Long stock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stock = stock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>请求三次时</p>
<img src="/2021/05/04/Redis2/Redis2.png" width="90%" height="90%">
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/04/Redis2/" data-id="ckoa6j9nm0003669icvgfaiyd" data-title="Redission" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-无锁cas(八)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/%E6%97%A0%E9%94%81cas(%E5%85%AB)/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T06:50:23.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/%E6%97%A0%E9%94%81cas(%E5%85%AB)/">无锁cas（篇八）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Java多线程-第八篇-无锁cas"><a href="#Java多线程-第八篇-无锁cas" class="headerlink" title="Java多线程 第八篇 无锁cas"></a>Java多线程 第八篇 无锁cas</h2><p>对于并发控制而言，锁是一种悲观策略，会阻塞线程执行。而无锁是一种乐观策略，它会假设对资源的访问时没有冲突的，既然没有冲突就不需要等待，线程不需要阻塞。那多个线程共同访问临界区的资源怎么办呢，无锁的策略采用一种比较交换技术<strong>CAS（compare and swap）</strong>来鉴别线程冲突，一旦检测到冲突，就重复当前操作直到没有冲突为止。</p>
<h3 id="CAS无锁实现原理"><a href="#CAS无锁实现原理" class="headerlink" title="CAS无锁实现原理"></a>CAS无锁实现原理</h3><h5 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h5><p>一个CAS方法包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期的值，N表示新值。只有当V的值等于E时，才会将V的值修改为N。如果V的值不等于E，说明已经被其他线程修改了，当前线程可以放弃此操作，也可以再次尝试次操作直至修改成功。基于这样的算法，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰（临界区值的修改），并进行恰当的处理。其中当前线程可以发现其他线程对临界区数据的修改，这点可以使用 volatile 进行保证,volatile 实现了JMM中的<strong>可见性</strong>。使得对临界区资源的修改可以马上被其他线程看到，它是通过添加内存屏障实现的。</p>
<h5 id="juc并发包下包含了实现了cas的原子类"><a href="#juc并发包下包含了实现了cas的原子类" class="headerlink" title="juc并发包下包含了实现了cas的原子类"></a>juc并发包下包含了实现了cas的原子类</h5><p>1.AtomicInteger/AtomicBoolean/AtomicLong<br>2.AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray<br>3.AtomicReference/AtomicStampedReference/AtomicMarkableReference</p>
<h5 id="最常用AtomicInteger"><a href="#最常用AtomicInteger" class="headerlink" title="最常用AtomicInteger"></a>最常用AtomicInteger</h5><p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处省略一万字代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, newValue))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AtomicInteger中真正存储数据的是value变量，而改变量是被<strong>volatile</strong>修饰的，保证了线程直接的可见性。还记得Integer中的value吗？Integer中的value是被final修饰的，是不可变对象。<br>getAndSet方法通过一个死循环不断尝试赋值操作。而真正的赋值操作交给了<strong>unsafe类</strong>来实现。</p>
<h5 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h5><p><em><strong>Unsafe</strong></em>类是CAS实现的核心</p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span>(var0.getClassLoader() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里<code>Unsafe</code>封装了一些类似于<strong>C++中指针</strong>的东西，该类中的方法都是<code>native</code>的，而且是<strong>原子</strong>的操作。原子性是通过CAS原子指令实现的，由处理器保证。</p>
<h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><p>1.<strong>ABA问题</strong></p>
<p>ABA：一个线程将某一内存地址中的数值A改成了B，接着又改成了A，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。</p>
<p>2.<strong>CAS造成CPU利用率增加</strong></p>
<p>3.<strong>会增加程序测试的复杂度</strong></p>
<p>4.<strong>只能保证一个共享变量的原子操作</strong></p>
<h3 id="jdk中的CAS实现"><a href="#jdk中的CAS实现" class="headerlink" title="jdk中的CAS实现"></a>jdk中的CAS实现</h3><h5 id="java-util-concurrent-atomic包"><a href="#java-util-concurrent-atomic包" class="headerlink" title="java.util.concurrent.atomic包"></a>java.util.concurrent.atomic包</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/04/%E6%97%A0%E9%94%81cas(%E5%85%AB)/" data-id="cko9mlwvo0000889i3p1z7zrk" data-title="无锁cas（篇八）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JMM及volatile关键字" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/03/JMM%E5%8F%8Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-date">
  <time class="dt-published" datetime="2021-05-03T14:50:23.000Z" itemprop="datePublished">2021-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/03/JMM%E5%8F%8Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/">JMM及volatile关键字 （篇七）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Java多线程-第七篇-JMM及volatile关键字"><a href="#Java多线程-第七篇-JMM及volatile关键字" class="headerlink" title="Java多线程 第七篇 JMM及volatile关键字"></a>Java多线程 第七篇 JMM及volatile关键字</h2><h3 id="JMM（Java内存区域）"><a href="#JMM（Java内存区域）" class="headerlink" title="JMM（Java内存区域）"></a>JMM（Java内存区域）</h3><p>Java虚拟机在运行程序时会把其自动管理的内存划分为几个区域：</p>
<p>所有线程共享区域：方法区（Method Area）<strong>（OOM可能出现的地方 ）</strong>，JVM堆（Java Heap）</p>
<p>线程私有区域：程序计数器(Program Counter Register)，虚拟机栈(Java Virtual Machine Stacks)，本地方法栈(Native Method Stacks)</p>
<h3 id="JMM的承诺"><a href="#JMM的承诺" class="headerlink" title="JMM的承诺"></a>JMM的承诺</h3><ol>
<li>原子性 保证指令不会受到上下文切换的影响（如synchronized关键字）</li>
<li>可见性 保证指令不会受到cpu缓存的影响</li>
<li>有序性 保证指令不会受并行优化的影响</li>
</ol>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>该关键字解决了可见性和有序性，volatile通过内存屏障来实现的</p>
<p>写屏障<br>会在对象写操作之后加写屏障，会对写屏障的之前的数据都同步到主存，并且保证写屏障的执行顺序在写屏障之前</p>
<p>读屏障<br>会在对象读操作之前加读屏障，会在读屏障之后的语句都从主存读，并保证读屏障之后的代码执行在读屏障之后</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>注意： <strong>volatile不能解决原子性，即不能通过该关键字实现线程安全。</strong></p>
<p>volatile应用场景：<strong>一个线程读取变量，另外的线程操作变量，加了该关键字后保证写变量后，读变量的线程可以及时感知。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/03/JMM%E5%8F%8Avolatile%E5%85%B3%E9%94%AE%E5%AD%97/" data-id="cko8pfiel0000ru9iayuh8w5o" data-title="JMM及volatile关键字 （篇七）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-死锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/03/%E6%AD%BB%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2021-05-03T13:50:23.000Z" itemprop="datePublished">2021-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/03/%E6%AD%BB%E9%94%81/">死锁 （篇六）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Java多线程-第六篇-死锁"><a href="#Java多线程-第六篇-死锁" class="headerlink" title="Java多线程 第六篇 死锁"></a>Java多线程 第六篇 死锁</h2><p>设想一个场景，A手握锁a，等候拿锁b，B拿着锁b，等待获取锁a。</p>
<h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>a. 竞争资源</p>
<p>系统中的资源可以分为两类：<br>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；<br>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。<br>产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）<br>产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
<p>b. 进程间推进顺序非法</p>
<p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁<br>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><p><strong>1、Jstack命令</strong></p>
<p><strong>2、JConsole工具</strong></p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p>
<p>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>1、以确定的顺序获得锁</p>
<p>如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。</p>
<p>2、超时放弃</p>
<p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/03/%E6%AD%BB%E9%94%81/" data-id="cko8pfiep0003ru9i52zjbxq6" data-title="死锁 （篇六）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-可重入锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/03/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2021-05-03T12:50:23.000Z" itemprop="datePublished">2021-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/03/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/">可重入锁 （篇五）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Java多线程-第五篇-可重入锁ReentrantLock"><a href="#Java多线程-第五篇-可重入锁ReentrantLock" class="headerlink" title="Java多线程 第五篇 可重入锁ReentrantLock"></a>Java多线程 第五篇 可重入锁ReentrantLock</h2><p>前面提到  </p>
<blockquote>
<p>LockSupport是非重入的。</p>
</blockquote>
<p>这篇来记录一下重入锁，主要以ReentrantLock为例，当然前面的synchronized也是可重入锁。</p>
<blockquote>
<p>可重入锁（也叫递归锁）：指的是同一线程外层函数获得锁之后，内层递归函数仍然可以获取该锁的代码，在同一线程在外层方法获取锁的时候+，在进入内层方法会自动获取锁。</p>
<p>也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>
</blockquote>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><p>ReentrantLock 实现了Java中锁的核心接口Lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//获取锁，获取不到lock就不罢休，不可被打断,即使当前线程被中断，线程也一直阻塞，直到拿到锁， 比较无赖的做法。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *获取锁，可中断，如果获取锁之前当前线程被interrupt了，</span></span><br><span class="line"><span class="comment">  *获取锁之后会抛出InterruptedException，并且停止当前线程；</span></span><br><span class="line"><span class="comment">  *优先响应中断</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//立即返回结果；尝试获得锁,如果获得锁立即返回ture,失败立即返回false</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试拿锁，可设置超时时间，超时返回false，即过时不候</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放锁</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前线程的Condition ，可多次调用</span></span><br><span class="line">   <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ReentrantLock私有public方法"><a href="#ReentrantLock私有public方法" class="headerlink" title="ReentrantLock私有public方法"></a>ReentrantLock私有public方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入boolean值,true时create一个公平锁，false为非公平锁</span></span><br><span class="line"> ReentrantLock(<span class="keyword">boolean</span> fair) </span><br><span class="line">   </span><br><span class="line"><span class="comment">//查看有多少线程等待锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//是否有线程等待抢锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//是否有指定线程等待抢锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//当前线程是否抢到锁。返回0代表没有</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//查询此锁是否由任何线程持有</span></span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> <span class="comment">//是否为公平锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h4 id="ReentrantLock中Condition的使用"><a href="#ReentrantLock中Condition的使用" class="headerlink" title="ReentrantLock中Condition的使用"></a>ReentrantLock中Condition的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span></span><br><span class="line"><span class="comment">	*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span></span><br><span class="line"><span class="comment">	*重要一点是：在当前持有Lock的线程中，当外部调用await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span></span><br><span class="line"><span class="comment">	*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//类似await(long time, TimeUnit unit) </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//唤醒指定线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//唤醒全部线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ReentrantLock.Condition的线程通信：<br>ReentrantLock.Condition是在粒度和性能上都优于Object的notify()、wait()、notifyAll()线程通信的方式。</p>
<p>Condition中通信方法相对Object的通信在粒度上是粒度更细化，表现在一个Lock对象上引入多个Condition监视器、通信方法中除了和Object对应的三个基本函数外，更是新增了线程中断、阻塞超时的函数；<br>Condition中通信方法相对Object的通信在性能上更高效，性能的优化表现在ReentrantLock比较synchronized的优化 </p>
<h4 id="ReentrantLock比synchronized优点"><a href="#ReentrantLock比synchronized优点" class="headerlink" title="ReentrantLock比synchronized优点"></a>ReentrantLock比synchronized优点</h4><ol>
<li>支持获取锁的超时时间</li>
<li>获取锁时可被打断</li>
<li>可设为公平锁</li>
<li>可以有不同的条件变量，即有多个waitSet，可以指定唤醒</li>
<li>灵活度高（synchronized更简单）</li>
</ol>
<h4 id="开发运用场景"><a href="#开发运用场景" class="headerlink" title="开发运用场景"></a>开发运用场景</h4><h5 id="1-公平锁，线程排序执行，防饿死应用场景；"><a href="#1-公平锁，线程排序执行，防饿死应用场景；" class="headerlink" title="1.公平锁，线程排序执行，防饿死应用场景；"></a>1.公平锁，线程排序执行，防饿死应用场景；</h5><p>公平锁原则必须按照锁申请时间上先到先得的原则分配机制场景；</p>
<p>1）.实现逻辑 上(包括：软件中函数计算、业务先后流程；硬件中操作实现中顺序逻辑)的顺序排队机制的场景；<br>软件场景：用户交互View中对用户输入结果分析类，分析过程后面算法依赖上一步结果的场景，例如：推荐算法实现[根据性别、年龄筛选]、阻塞队列的实现；<br>硬件场景：需要先分析确认用户操作类型硬件版本或者厂家，然后发出操作指令；例如：自动售货机；</p>
<p>2）.现实 生活中 时间排序的 公平原则：例如：客服分配，必须是先到先服务，不能出现饿死现象；</p>
<h5 id="2-非公平锁-效率的体现者；"><a href="#2-非公平锁-效率的体现者；" class="headerlink" title="2.非公平锁,效率的体现者；"></a>2.非公平锁,效率的体现者；</h5><h5 id="3-ReentrantLock-Condition线程通信"><a href="#3-ReentrantLock-Condition线程通信" class="headerlink" title="3.ReentrantLock.Condition线程通信"></a>3.ReentrantLock.Condition线程通信</h5><p>两个<strong>线程之间交替打印</strong> 26英文字母和阿拉伯数字为demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">alternateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">65</span>; i &lt; <span class="number">91</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;----------thread1------- &quot;</span> + (<span class="keyword">char</span>) i);</span><br><span class="line">                    condition2.signal();</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition2.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;----------thread2------- &quot;</span> + i);</span><br><span class="line">                    condition1.signal();</span><br><span class="line">                    condition2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-中断杀器应用"><a href="#4-中断杀器应用" class="headerlink" title="4.中断杀器应用"></a>4.中断杀器应用</h5><p>ReentrantLock中lockInterruptibly( )和lock( )最大的区别就是中断相应问题：<br>lock()是支持中断相应的阻塞试的获取方式，因此即使主动中断了锁的持有者，但是它不能立即unlock(),仍然要机械版执行完所有操作才会释放锁。<br>lockInterruptibly( )是 优先响应中断的，这样有个优势就是可以通过tryLock()、tryLock(timeout, TimeUnit.SECONDS)方法，中断优先级低的Task，及时释放资源给优先级更高的Task</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           lock.lockInterruptibly();</span><br><span class="line">           <span class="keyword">if</span> (lock.tryLock(timeout, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               <span class="comment">//TODO</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//超时直接中断优先级低的Task</span></span><br><span class="line">               Thread.currentThread().interrupt();</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="comment">//TODO</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexwooly.gitee.io/2021/05/03/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/" data-id="cko8pfieo0001ru9ia7tkgnvv" data-title="可重入锁 （篇五）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">Java多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="tag">Java工具类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jwt/" rel="tag">jwt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 20px;">Java多线程</a> <a href="/tags/Java%E5%B7%A5%E5%85%B7%E7%B1%BB/" style="font-size: 13.33px;">Java工具类</a> <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">Java数据结构</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 16.67px;">Redis</a> <a href="/tags/jwt/" style="font-size: 10px;">jwt</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池（篇九）</a>
          </li>
        
          <li>
            <a href="/2021/05/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/">分布式架构理论</a>
          </li>
        
          <li>
            <a href="/2021/05/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C/">Java基本数据结构及其操作</a>
          </li>
        
          <li>
            <a href="/2021/05/06/%E5%B8%B8%E7%94%A8sql%EF%BC%88MySQL%EF%BC%89/">常用sql（MySQL）</a>
          </li>
        
          <li>
            <a href="/2021/05/05/Redis3/">Redis 事务</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 AlexWoo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>